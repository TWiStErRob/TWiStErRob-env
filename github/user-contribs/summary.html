<html lang="en">
<head>
	<title>Contributor Summary</title>
	<!--[if IE 0]>
	Hack for IntelliJ IDEA so it recognizes d3 below.
	<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.js"></script>
	<![endif]-->
	<script type="module">
		import * as d3 from "https://cdn.skypack.dev/d3@7";

		const windowWidth = window.innerWidth;
		const windowHeight = window.innerHeight;
		// Copyright 2021 Observable, Inc.
		// Released under the ISC license.
		// https://observablehq.com/@d3/horizon-chart
		function HorizonChart(data, {
			x = d => d.w * 1000, // given d in data, returns the (temporal) x-value
			y = d => d.c, // given d in data, returns the (quantitative) y-value
			z = d => d.login, // given d in data, returns the (categorical) z-value
			defined,// = d => d.c > 0, // for gaps in data
			curve = d3.curveStep, // method of interpolation between points
			marginTop = 20, // top margin, in pixels
			marginRight = 0, // right margin, in pixels
			marginBottom = 0, // bottom margin, in pixels
			chartStart = 50, // left margin, in pixels
			width = windowWidth, // outer width, in pixels
			size = (windowHeight - marginTop - marginBottom) / new d3.InternSet(d3.map(data, z)).size, // outer height of a single horizon, in pixels
			bands = 1, // number of bands
			padding = 0, // separation between adjacent horizons
			xType = d3.scaleTime, // type of x-scale
			xDomain, // [xmin, xmax]
			xRange = [chartStart, width - marginRight], // [left, right]
			yType = d3.scaleLinear, // type of y-scale
			yDomain, // [ymin, ymax]
			yRange = [size, size - bands * (size - padding)], // [bottom, top]
			zDomain, // array of z-values
			scheme = d3.schemeGreys, // color scheme; shorthand for colors
			colors = scheme[Math.max(3, bands)], // an array of colors
		} = {}) {
			// Compute values.
			const X = d3.map(data, x);
			const Y = d3.map(data, y);
			const Z = d3.map(data, z);
			if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
			const D = d3.map(data, defined);

			// Compute default domains, and unique the z-domain.
			if (xDomain === undefined) xDomain = d3.extent(X);
			if (yDomain === undefined) yDomain = [0, d3.max(Y)];
			if (zDomain === undefined) zDomain = Z;
			zDomain = new d3.InternSet(zDomain);

			// Omit any data not present in the z-domain.
			const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));

			// Compute height.
			const height = zDomain.size * size + marginTop + marginBottom;

			// Construct scales and axes.
			const xScale = xType(xDomain, xRange);
			const yScale = yType(yDomain, yRange);

			// A unique identifier for clip paths (to avoid conflicts).
			const uid = `O-${Math.random().toString(16).slice(2)}`;

			// Construct an area generator.
			const area = d3.area()
					.defined(i => D[i])
					.curve(curve)
					.x(i => xScale(X[i]))
					.y0(yScale(0))
					.y1(i => yScale(Y[i]));

			const svg = d3.create("svg")
					.attr("width", width)
					.attr("height", height)
					.attr("viewBox", [0, 0, width, height])
					.attr("style", "max-width: 100%; height: auto; height: intrinsic;")
					.attr("font-family", "sans-serif")
					.attr("font-size", 10);

			const g = svg.selectAll("g")
					.data(d3.group(I, i => Z[i]))
					.join("g")
					.attr("transform", (_, i) => `translate(0,${i * size + marginTop + 10})`);

			const defs = g.append("defs");

			defs.append("clipPath")
					.attr("id", (_, i) => `${uid}-clip-${i}`)
					.append("rect")
					.attr("y", padding)
					.attr("width", width)
					.attr("height", size - padding);

			defs.append("path")
					.attr("id", (_, i) => `${uid}-path-${i}`)
					.attr("d", ([, I]) => area(I));

			g
					.attr("clip-path", (_, i) => `url(${new URL(`#${uid}-clip-${i}`, location)})`)
					.selectAll("use")
					.data((d, i) => new Array(bands).fill(i))
					.join("use")
					.attr("fill", (_, i) => colors[i + Math.max(0, 3 - bands)])
					.attr("transform", (_, i) => `translate(0,${i * size})`)
					.attr("xlink:href", (i) => `${new URL(`#${uid}-path-${i}`, location)}`);

			g.append("text")
					.attr("x", 0)
					.attr("y", (size + padding) / 2)
					.attr("dy", "0.35em")
					.text(([z]) => z);

			svg.append("g")
					.attr("transform", `translate(0,${marginTop})`)
					.style("font", "3px times")
					.call(
							d3.axisBottom(xScale)
									.ticks(d3.timeMonth.every(1))
									.tickFormat(d3.timeFormat("%b"))
									.tickSizeOuter(0)
					)
					.call(g => g.select(".domain").remove());

			// Year ticks, but without labels.
			svg.append("g")
					.attr("transform", `translate(0,${marginTop})`)
					.call(
							d3.axisTop(xScale)
									.ticks(d3.timeYear.every(1))
									.tickFormat(() => null)
									.tickSizeOuter(0)
					)
					.call(g => g.select(".domain").remove());

			// Year ticks, at every half year (so that year label is centered).
			svg.append("g")
					.attr("transform", `translate(0,${marginTop})`)
					.call(
							d3.axisTop(xScale)
									.ticks(d3.timeMonth.every(6))
									.tickSize(0) // remove tick line, label only.
									.tickFormat((d) => {
										if (d.getUTCMonth() === 0) {
											return null;
										} else {
											return d3.timeFormat("%Y")(d);
										}
									})
					)
					.call(g => g.select(".domain").remove());

			return svg.node();
		}

		const summary = await d3.json("summary.json");
		const prep = summary.flatMap(d => d.contribs.map(c => ({
			login: d.login,
			repo: d.repo,
			a: c.a,
			c: c.c,
			d: c.d,
			w: c.w
		})));
		// const data = d3.sort(prep, d => d.login, d => d.repo, d => d.w);
		const logins = new d3.InternSet(d3.map(prep, d => d.login));
		const sortedLogins = d3.sort(logins, l => d3.min(d3.map(d3.filter(prep, d => d.login === l && d.c > 0), d => d.w)));
		const data = d3.sort(prep, d => sortedLogins.indexOf(d.login), d => d.repo);
		console.log(data);
		console.log(data[0]);
		const chart = HorizonChart(data)
		document.getElementById("main").append(chart);
	</script>
	<style>
		html, body {
			margin: 0;
			padding: 0;
		}
	</style>
</head>
<body>
<div id="main">
</div>
</body>
